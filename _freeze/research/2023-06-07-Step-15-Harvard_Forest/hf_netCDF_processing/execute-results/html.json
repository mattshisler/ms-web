{
  "hash": "e572daa2a7074ead5f3fc05763ffebff",
  "result": {
    "markdown": "---\nformat:\n  html:\n    code-fold: false\nexecute:\n  eval: false\n  freeze: true\n---\n\n#\n# ```{r}\n# #| label: load-packages\n# #| output: false\n# #| code-summary: \"Code: Load the packages\"\n#\n# library(tidyverse)\n# library(tmap)\n# library(terra)\n# library(ncdf4)\n# library(lubridate)\n# library(viridis)\n# ```\n#\n# ```{r}\n# #| code-fold: true\n#\n# ReadNcTs <- function(ncfile) {\n#     r <- rast(ncfile)\n#     # Get time\n#     nc_in <- nc_open(ncfile)\n#     dates <- ncvar_get(nc_in, \"time\")\n#     nc_close(nc_in)\n#     # Assign time to the original image object\n#     if (nchar(dates[1]) == 8) {\n#         fm <- \"%Y%m%d\"\n#     } else if (nchar(dates[1] == 7)) {\n#         fm <- \"%Y%j\"\n#     }\n#     time(r) <- as.Date(as.character(dates), tryFormats = fm)\n#\n#     # Reorder the layers by time\n#     r <- r[[order(time(r))]]\n#\n#     # Get map projection\n#     tif <- rast(list.files(dirname(ncfile), \".tif$\", full.names = TRUE)[1])\n#     crs(r) <- crs(tif)\n#\n#     return(r)\n# }\n# ```\n#\n# There are over 3000 layers in the original dataset. I suspect that many of the layers are all NA.\n# I'll compute the minmax of each layer, then filter out all layers with an NaN min. We are left with about 1300 layers.\n#\n# ```{r}\n# # Read in the data and print information\n# hf <- ReadNcTs(\"data/harvard_forest_evi2.nc\")\n# hf\n# ncell(hf)\n#\n# # plot a representative cell\n# plot(hf[[time(hf) == \"2020-06-22\"]], range = c(0,1))\n#\n# # set min max of each layer\n# setMinMax(hf)\n# ```\n#\n# ```{r}\n# # filter out layers with NaN min implying that the entire layer is NaN.\n# hf_clean <- hf[[!is.nan(minmax(hf)[1,])]]\n#\n# hf\n#\n# # print info again.\n# hf_clean\n# ```\n#\n# Next I want to see the pixel density of each layer. I suspect many layers have many NaN values. I'll loop over layers and store the pixel density in a data.frame. This is a slow loop - possibly because the data is not being read into RAM, but is instead accessed on the hard drive.\n\n::: {.cell}\n\n```{.r .cell-code}\nlayer_dens <- data.frame(matrix(0, nrow = dim(hf_rmNaNlyrs)[3], ncol = 2))\ncolnames(layer_dens) <- c(\"count_good_pix\", \"date\")\n\nfor (layer in 1:dim(hf_rmNaNlyrs)[3]){\n  temp <- values(hf_rmNaNlyrs[[layer]])\n\n  layer_dens$count_good_pix[layer] <- sum(!is.nan(temp[,1]))\n  layer_dens$date[layer] <- time(hf_rmNaNlyrs)[layer]\n\n}\n\nas.Date(layer_dens$date)\n\nlayer_dens <- layer_dens %>%\n  mutate(ratio_good_pix = count_good_pix/ncell(hf_rmNaNlyrs)) %>%\n  mutate(date = time(hf_rmNaNlyrs)) %>%\n  mutate(year = year(date)) %>%\n  mutate(month = month(date)) %>%\n  mutate(mday = mday(date)) %>%\n  mutate(yday = yday(date)) %>%\n  mutate(tsday = as.numeric(date - min(date)))\n\nas.numeric(layer_dens$date[5]-layer_dens$date[1])\n\n\n\nhist(layer_dens$ratio_good_pix)\nplot(layer_dens$year, layer_dens$ratio_good_pix)\n\nplot(layer_dens$yday, layer_dens$ratio_good_pix)\n\nplot(layer_dens$tsday, layer_dens$ratio_good_pix)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(ratio_good_pix ~ year, data = layer_dens)\n\nplot(table(layer_dens$year))\n```\n:::\n\n\nWe can plot the pixel density boxplots by day of year as well, though squeezing this many adjacent boxplots together makes it difficult to see much. One thing that is obvious is that we get better pixel densities between days 110 and 310, most likely because it is summertime.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(ratio_good_pix ~ yday, data = layer_dens)\n\nplot(table(layer_dens$yday))\n```\n:::\n\n\nNext, let us consider the extracting data from the spatraster object into a data frame.\n\n::: {.cell}\n\n```{.r .cell-code}\n# length(unique(names(hf_rmNaNlyrs)))\n# length(unique(time(hf_rmNaNlyrs)))\n\n\n#\n# test <- as.data.frame(hf_clean, xy=TRUE, cells=TRUE)\n\nlong_hf <- hf_clean %>%\n  as.data.frame(xy=TRUE, cells=TRUE) %>%\n  pivot_longer(cols = starts_with(\"EVI\"), values_to = \"EVI2\", values_drop_na = T)\n\nwrite.csv(long_hf, file = \"long_hf.csv\", row.names = F)\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}