{
  "hash": "56d8d924b64b3340705bee90e7179b57",
  "result": {
    "markdown": "---\ntitle: \"Step 9 - The multivariate CAR model\"\ndescription: \"We explore extensions of the univariate CAR model described in Hierarchical Modeling and Analysis for Spatial data.\"\nauthor:\n  - name: Matthew Shisler\n    affiliation: North Carloina State University - Department of Statistics\n    affiliation-url: https://statistics.sciences.ncsu.edu/ \ncategories: [Bayesian, MCMC, Spatial, CAR] # self-defined categories\ndraft: false \nformat:\n  html: \n    code-fold: true\nexecute: \n  cache: false\n  freeze: auto\n---\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Code: Load the packages\"}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(viridis)\n```\n:::\n\n\n## Intro\n\nHere we will extend the univariate CAR model to the multivariate case. \n\nConsider a spatial domain $\\mathcal{D} \\in \\mathbb{R}^2$ that is partitioned into $n$ areal units. In the univariate case we specified a spatial random effect $\\boldsymbol\\phi = (\\phi_1,\\dots,\\phi_n)$ meant to capture the spatial dependence. In the multivariate case we specify a spatial random vector $\\boldsymbol\\phi^T = (\\boldsymbol\\phi_1, \\boldsymbol\\phi_2,\\dots,\\boldsymbol\\phi_3)$ where each $\\boldsymbol\\phi_i = (\\phi_{i1}, \\phi_{i2},\\dots, \\phi_{ip})$ is $p \\times 1$.\n\nThe joint distribution of $\\boldsymbol\\phi_i$ is derived from the full conditional distributions.\nUnder the Markov Random Field (MRF) assumption, the conditional distributions can be specified as\n$$\np(\\boldsymbol\\phi_i|\\boldsymbol\\phi_{j\\ne i}, \\Gamma_i) = N\\left(\\sum_{i \\sim j} \\mathbf{B}_{ij}\\boldsymbol\\phi_j, \\Gamma_i\\right), \\quad i,j = 1,\\dots,n.\n$$\n\nwhere $\\Gamma_i$ and $\\mathbf{B}_{ij}$ are $p \\times p$ matrices.\n\nRecall the role of $\\Gamma_i$ and $\\mathbf{B}_{ij}$ are analogous to the roles of $\\tau_i^2$ and $b_{ij}$, respectively, in the univariate CAR models. The matrix $\\Gamma_i$ is the within unit covariance matrix which describes the dependence of the variables in the vector $\\boldsymbol\\phi_i$. The matrix $\\mathbf{B}_{ij}$ is the matrix that allows us to weight the neighboring observations of location $i$ that are conditioned on in the full conditional. A convenient special case is to set $\\mathbf{B}_{ij} = b_{ij}\\mathbf{I}_p$ where $b_{ij} = w_{ij}/w_{i+}$. Recall, for a neighborhood matrix $\\mathbf{W} = \\{w_ij\\}$,\n$$\nw_{ij} = \n\\begin{cases}\n1 \\quad \\text{if} \\quad j \\in \\mathcal{N}(i),\\\\\n0 \\quad \\text{otherwise}.\n\\end{cases}\n$$\nand $w_{i+} = \\sum_{j=1}^pw_{ij}$, i.e. the number of neighbors of location $i$, $|\\mathcal{N}(i)|$.\n\n\nSpecifying the conditional distributions in this way implies the unique joint distribution, via Brook's Lemma, to be\n$$\np(\\boldsymbol\\phi \\;| \\;\\{\\Gamma_i\\}) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}})\\phi\\right\\}\n$$\nwhere $\\Gamma$ is block-diagonal with block $\\Gamma_i$, and $\\tilde{\\mathbf{B}}$ is $np \\times np$ with the $(i,j)$-th block $\\mathbf{B}_{ij}$.\n\nOf course, a requirement for the multivariate normal distribution is symmetry of $\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}})$. Setting $\\mathbf{B}_{ij} = b_{ij}\\mathbf{I}_p$ where $b_{ij} = w_{ij}/w_{i+}$ leads to the symmetry condition $b_{ij}\\Gamma_j = b_{ji}\\Gamma_i$. Further, a common simplifying assumption would be consider the within unit covariance equal. That is, set $\\Gamma_i = w_{i+}^{-1}\\Sigma$ where $\\Sigma$ is the $p \\times p$ within unit covariance matrix for $\\boldsymbol\\phi_i$ and common across spatial locations $i=1,\\dots,n$.\n\nUnder these assumptions we can write $\\Gamma = (\\mathbf{D}^{-1}\\otimes\\Sigma)$ where $\\mathbf{D}$ is an $n \\times n$ diagonal matrix with $\\mathbf{D}_{ii} = w_{i+}$. And also $\\tilde{\\mathbf{B}} = \\mathbf{B}\\otimes\\mathbf{I}_n$ where $\\mathbf{B}_{ij} = w_{ij}/w_{i+}$, not the block matrix specification given earlier. \n\nWith this in mind, we can write the precision of the above joint distribution in an alternate form,\n$$\n\\begin{align*}\n\n\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}}) &= (\\mathbf{D}^{-1} \\otimes \\Sigma)^{-1}(\\mathbf{I}_{np} - \\mathbf{B}\\otimes \\mathbf{I}_p)\\\\\n&= (\\mathbf{D} \\otimes \\Sigma^{-1})(\\mathbf{I}_{np} - \\mathbf{B}\\otimes \\mathbf{I}_p) & \\text{Kronecker Prod - Inverse}\\\\\n&= (\\mathbf{D} \\otimes \\Sigma^{-1}) - (\\mathbf{D} \\otimes \\Sigma^{-1})( \\mathbf{B}\\otimes \\mathbf{I}_n) & \\text{(Matrix Mult - distributive wrt matrix addition)}\\\\\n&= (\\mathbf{D} \\otimes \\Sigma^{-1}) - (\\mathbf{D}\\mathbf{B}) \\otimes (\\Sigma^{-1}\\mathbf{I}_n) & \\text{(Kronecker Prod - mixed-product property)}\\\\\n&= (\\mathbf{D} - \\mathbf{D}\\mathbf{B})\\otimes\\Sigma^{-1} & \\text{(Kronecker Prod - distributive wrt matrix addition)}\\\\\n&= (\\mathbf{D} - \\mathbf{W}) \\otimes \\Sigma^{-1} & \\text{need to verify?}\n\\end{align*}\n$$\n\nLet's turn to a simple example. Consider a spatial domain partitioned into $n=4$ areal units and a multivariate response with $p=2$.\n\nThis is a test push from new clone.\n\nFirst, the spatial domain.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 4\nspat_domain <- expand.grid(x = 1:sqrt(n), y = 1:sqrt(n))\nspat_domain$label <- 1:n\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spat_domain) +\n  geom_tile(aes(x, y), linewidth = 2, color = \"grey50\", fill=\"white\") +\n  geom_text(aes(x, y, label=label), size = 15) +\n  coord_fixed() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nNext, the adjacency matrix $\\mathbf{W}$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspat_domain_g <- make_lattice(c(sqrt(n),sqrt(n)), mutual = TRUE)\nW <- as.matrix(as_adjacency_matrix(spat_domain_g, sparse=1))\nW\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    1    0\n[2,]    1    0    0    1\n[3,]    1    0    0    1\n[4,]    0    1    1    0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nB <- W/rowSums(W)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.0  0.5  0.5  0.0\n[2,]  0.5  0.0  0.0  0.5\n[3,]  0.5  0.0  0.0  0.5\n[4,]  0.0  0.5  0.5  0.0\n```\n:::\n\n```{.r .cell-code}\nBtilde <- kronecker(B, diag(2))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- diag(rowSums(W))\n\nsolve(D)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.5  0.0  0.0  0.0\n[2,]  0.0  0.5  0.0  0.0\n[3,]  0.0  0.0  0.5  0.0\n[4,]  0.0  0.0  0.0  0.5\n```\n:::\n\n```{.r .cell-code}\np <- 2\ncapSigma <- matrix(c(1,0.7,\n                     0.7,1), byrow = T, ncol=p)\n\ncapLambda <- kronecker(solve(D), capSigma)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA1 <- solve(capLambda)%*%(diag(p*n) - Btilde)\nA2 <- kronecker((D - W), solve(capSigma))\n\nall(A1 == A2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}