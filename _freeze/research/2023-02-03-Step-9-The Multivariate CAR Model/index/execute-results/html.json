{
  "hash": "b8a52bdb2bd7c6775d6e2d2c461bb56e",
  "result": {
    "markdown": "---\ntitle: \"Step 9 - The multivariate CAR model\"\ndescription: \"We explore extensions of the univariate CAR model described in Hierarchical Modeling and Analysis for Spatial data.\"\nauthor:\n  - name: Matthew Shisler\n    affiliation: North Carloina State University - Department of Statistics\n    affiliation-url: https://statistics.sciences.ncsu.edu/ \ncategories: [Bayesian, MCMC, Spatial, CAR] # self-defined categories\ndraft: false \nformat:\n  html: \n    code-fold: true\nexecute: \n  cache: false\n  freeze: auto\n---\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Code: Load the packages\"}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(viridis)\n```\n:::\n\n\n## Intro\n\nThis is a fourth test to push from macbook.\n\nHere we will extend the univariate CAR model to the multivariate case. \n\nConsider a spatial domain $\\mathcal{D} \\in \\mathbb{R}^2$ that is partitioned into $n$ areal units. In the univariate case we specified a spatial random effect $\\boldsymbol\\phi = (\\phi_1,\\dots,\\phi_n)$ meant to capture the spatial dependence. In the multivariate case, say of dimension $p$, we specify a spatial random vector $\\boldsymbol\\phi^T = (\\boldsymbol\\phi_1, \\boldsymbol\\phi_2,\\dots,\\boldsymbol\\phi_3)$ which is $np \\times 1$ and each $\\boldsymbol\\phi_i = (\\phi_{i1}, \\phi_{i2},\\dots, \\phi_{ip})$ is $p \\times 1$.\n\nThe joint distribution of $\\boldsymbol\\phi$ is derived from the full conditional distributions of $\\boldsymbol\\phi_i$.\nUnder the Markov Random Field (MRF) assumption, the conditional distributions of $\\boldsymbol\\phi_i$ can be specified as\n$$\np(\\boldsymbol\\phi_i|\\boldsymbol\\phi_{j\\ne i}, \\Gamma_i) = N\\left(\\sum_{i \\sim j} \\mathbf{B}_{ij}\\boldsymbol\\phi_j, \\Gamma_i\\right), \\quad i,j = 1,\\dots,n.\n$$\n\nwhere $\\Gamma_i$ and $\\mathbf{B}_{ij}$ are $p \\times p$ matrices. Here we $i \\tilde j$ to say that $j$ is in the neighborhood of $i$, i.e. $j \\in \\mathcal{N}(i)$.\n\nThe role of $\\Gamma_i$ and $\\mathbf{B}_{ij}$ are analogous to the roles of $\\tau_i^2$ and $b_{ij}$, respectively, in the univariate CAR models. The matrix $\\Gamma_i$ is the within unit covariance matrix which describes the dependence of the variables in the vector $\\boldsymbol\\phi_i$. The matrix $\\mathbf{B}_{ij}$ is the matrix that allows us to weight the neighboring observations of location $i$ that are conditioned on. A convenient special case is to set $\\mathbf{B}_{ij} = b_{ij}\\mathbf{I}_p$ where $b_{ij} = w_{ij}/w_{i+}$. Recall, for a neighborhood matrix $\\mathbf{W} = \\{w_{ij}\\}$,\n$$\nw_{ij} = \n\\begin{cases}\n1 \\quad \\text{if} \\quad j \\in \\mathcal{N}(i),\\\\\n0 \\quad \\text{otherwise}.\n\\end{cases}\n$$\nand $w_{i+} = \\sum_{j=1}^pw_{ij}$, i.e. the number of neighbors of location $i$, $|\\mathcal{N}(i)|$.\n\n\nSpecifying the conditional distributions in this way implies the unique joint distribution, via Brook's Lemma, to be\n$$\np(\\boldsymbol\\phi \\;| \\;\\{\\Gamma_i\\}) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}})\\phi\\right\\}\n$$\nwhere $\\Gamma$ is block-diagonal with block $\\Gamma_i$, and $\\tilde{\\mathbf{B}}$ is $np \\times np$ with the $(i,j)$-th block $\\mathbf{B}_{ij}$.\n\nOf course, a requirement for the multivariate normal distribution is symmetry of $\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}})$. Setting $\\mathbf{B}_{ij} = b_{ij}\\mathbf{I}_p$ where $b_{ij} = w_{ij}/w_{i+}$ leads to the symmetry condition $b_{ij}\\Gamma_j = b_{ji}\\Gamma_i$. Further, a common simplifying assumption would be consider the within unit covariance equal. That is, set $\\Gamma_i = w_{i+}^{-1}\\Sigma$ where $\\Sigma$ is the $p \\times p$ within unit covariance matrix for $\\boldsymbol\\phi_i$ and common across spatial locations $i=1,\\dots,n$.\n\nUnder these assumptions we can write $\\Gamma = (\\mathbf{D}^{-1}\\otimes\\Sigma)$ where $\\mathbf{D}$ is an $n \\times n$ diagonal matrix with $\\mathbf{D}_{ii} = w_{i+}$. And also $\\tilde{\\mathbf{B}} = \\mathbf{B}\\otimes\\mathbf{I}_p$ where $\\mathbf{B}$ is a $n \\times n$ matrix and elements of $\\mathbf{B}$ are $\\mathbf{B} = \\{b_{ij}\\} = \\{w_{ij}/w_{i+}\\}$, not to be confused with the block matrix specification $\\mathbf{B}_{ij}$ given previously. \n\nWith this in mind, we can write the precision of the above joint distribution in an alternate form,\n\n\\begin{align*}\n\n\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}}) &= (\\mathbf{D}^{-1} \\otimes \\Sigma)^{-1}(\\mathbf{I}_{np} - \\mathbf{B}\\otimes \\mathbf{I}_p)\\\\\n&= (\\mathbf{D} \\otimes \\Sigma^{-1})(\\mathbf{I}_{np} - \\mathbf{B}\\otimes \\mathbf{I}_p) & \\text{Kronecker Prod - Inverse}\\\\\n&= (\\mathbf{D} \\otimes \\Sigma^{-1}) - (\\mathbf{D} \\otimes \\Sigma^{-1})( \\mathbf{B}\\otimes \\mathbf{I}_p) & \\text{(Matrix Mult - distributive wrt matrix addition)}\\\\\n&= (\\mathbf{D} \\otimes \\Sigma^{-1}) - (\\mathbf{D}\\mathbf{B}) \\otimes (\\Sigma^{-1}\\mathbf{I}_p) & \\text{(Kronecker Prod - mixed-product property)}\\\\\n&= (\\mathbf{D} - \\mathbf{D}\\mathbf{B})\\otimes\\Sigma^{-1} & \\text{(Kronecker Prod - distributive wrt matrix addition)}\\\\\n&= (\\mathbf{D} - \\mathbf{W}) \\otimes \\Sigma^{-1}\n\\end{align*}\n\nwhere the last step follows from the fact that $\\mathbf{B} = \\mathbf{D}^{-1}\\mathbf{W}$.\n\nNow there is no need to construct a large block-diagonal $\\Gamma$ matrix. Also, the neighborhood matrix $\\mathbf{W}$ and $\\mathbf{D}$, the diagonal matrix of its row sums, are fixed and known quantities easily computed outside of any MCMC sampling loop. The joint distribution is then\n\n$$\np(\\boldsymbol\\phi \\;| \\Sigma) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\left((\\mathbf{D} - \\mathbf{W})\\otimes \\Sigma^{-1}\\right)\\phi\\right\\}\n$$\nHowever, we again encounter the issue that $(\\mathbf{D} - \\mathbf{W}) \\otimes \\Sigma^{-1}$ is singular, since $(\\mathbf{D} - \\mathbf{W})$ is singular. This motivates the introduction of a scalar parameter, $\\rho$, also analogous to the univariate case. There are in fact more general conditions for recovering positive definiteness, but these are not explored here. More details can be found in. . .\n\nIntroducing $\\rho$ results in a proper joint distribution with form\n\n$$\np(\\boldsymbol\\phi \\;| \\Sigma) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\left((\\mathbf{D} - \\rho\\mathbf{W})\\otimes \\Sigma^{-1}\\right)\\boldsymbol\\phi\\right\\}\n$$\nEven so, a model which assumes a shared $\\rho$ parameter across elements of $\\boldsymbol\\phi_i$ may be too restrictive by assuming that the \"strength of spatial dependence\" is the same for each variable in the multivariate response. Further models have been developed that allow for different $\\rho_k$ for variables $k=1,\\dots,p$. \n\nThis approach requires a re-arrangement of $\\boldsymbol\\phi$. Where previously $\\boldsymbol\\phi$ stacked $n$ vectors of length $p$ on top of each other, now consider $\\boldsymbol\\phi'$ to stack $p$ vectors of length $n$. That is we collect the $n$ instances of the $p$-th element of $\\boldsymbol\\phi_i$, $i=1,\\dots,n$. This operation is essentially transforming the vectorization of the $n \\times p$ matrix representation of $\\boldsymbol\\phi$ into the vectorization of its transpose and is accomplished via a *commutation* matrix.\n\nSome things to think about. Viewing $\\boldsymbol\\phi$ as a vectoratization of a matrix $\\Phi$. Then we can commute $\\boldsymbol\\phi = \\text{vec}(\\Phi)$ by applying the commutation matrix $\\mathbf{K}^{(p,n)}$ for the result $\\mathbf{K}^{(p,n)}\\text{vec}(\\Phi) = \\text{vec}(\\Phi^T)$. Given that\n\n$$\n\\text{vec}(\\Phi) = \\boldsymbol\\phi \\sim N\\left(\\boldsymbol 0, (\\mathbf{D}-\\rho\\mathbf{W})^{-1} \\otimes \\Lambda\\right)\n$$\n\nthen the result of left multiplying by the commutation matrix yields the distribution,\n$$\n\\begin{align*}\n\\mathbf{K}^{(p,n)}\\text{vec}(\\Phi) = \\text{vec}(\\Phi^T) &\\sim N\\left(\\boldsymbol 0, \\mathbf{K}^{(p,n)}\\left[(\\mathbf{D}-\\rho\\mathbf{W})^{-1} \\otimes \\Lambda\\right]\\left(\\mathbf{K}^{(p,n)}\\right)^T\\right)\\\\\n&\\sim N\\left(\\boldsymbol 0, \\mathbf{K}^{(p,n)}\\left[(\\mathbf{D}-\\rho\\mathbf{W})^{-1} \\otimes \\Lambda\\right]\\mathbf{K}^{(n,p)}\\right)\\\\\n&\\sim N\\left(\\boldsymbol 0, \\left[\\Lambda \\otimes(\\mathbf{D}-\\rho\\mathbf{W})^{-1}\\right]\\right) \n\\end{align*}\n$$\n\nThe effect is that the Kronecker product is commuted. When the resulting Kronecker product is expanded, the elements of the common non-spatial covariance matrix $\\Lambda$ are multiplied with $(\\mathbf{D}-\\rho\\mathbf{W})$ individually as scalars. It is in this form that we can introduce different $\\rho_k$ for each of the $p$ elements. That is, different strengths of spatial correlation for each variate in the multivariate response vector.\n\nThis allows us to \"break up\" elements of $\\Sigma$ and associate them with difference values of $\\rho_k$.\n\n\n\nLet's turn to a simple example. Consider a spatial domain partitioned into $n=4$ areal units and a multivariate response with $p=2$.\n\n\nFirst, the spatial domain.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 4\nspat_domain <- expand.grid(x = 1:sqrt(n), y = 1:sqrt(n))\nspat_domain$label <- 1:n\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(spat_domain) +\n  geom_tile(aes(x, y), linewidth = 2, color = \"grey50\", fill=\"white\") +\n  geom_text(aes(x, y, label=label), size = 15) +\n  coord_fixed() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nNext, the adjacency matrix $\\mathbf{W}$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspat_domain_g <- make_lattice(c(sqrt(n),sqrt(n)), mutual = TRUE)\nW <- as.matrix(as_adjacency_matrix(spat_domain_g, sparse=1))\nW\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    1    0\n[2,]    1    0    0    1\n[3,]    1    0    0    1\n[4,]    0    1    1    0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nB <- W/rowSums(W)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.0  0.5  0.5  0.0\n[2,]  0.5  0.0  0.0  0.5\n[3,]  0.5  0.0  0.0  0.5\n[4,]  0.0  0.5  0.5  0.0\n```\n:::\n\n```{.r .cell-code}\nBtilde <- kronecker(B, diag(2))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nD <- diag(rowSums(W))\n\nsolve(D)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.5  0.0  0.0  0.0\n[2,]  0.0  0.5  0.0  0.0\n[3,]  0.0  0.0  0.5  0.0\n[4,]  0.0  0.0  0.0  0.5\n```\n:::\n\n```{.r .cell-code}\np <- 2\ncapSigma <- matrix(c(1,0.7,\n                     0.7,1), byrow = T, ncol=p)\n\ncapLambda <- kronecker(solve(D), capSigma)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nA1 <- solve(capLambda)%*%(diag(p*n) - Btilde)\nA2 <- kronecker((D - W), solve(capSigma))\n\nall(A1 == A2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}