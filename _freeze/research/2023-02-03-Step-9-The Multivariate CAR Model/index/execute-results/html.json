{
  "hash": "6e93642673049c4c0d6b5aa5b1202c48",
  "result": {
    "markdown": "---\ntitle: \"Step 9 - The multivariate CAR model with common strength of spatial correlation\"\ndescription: \"We explore extensions of the univariate CAR model described in Hierarchical Modeling and Analysis for Spatial data.\"\nauthor:\n  - name: Matthew Shisler\n    affiliation: North Carloina State University - Department of Statistics\n    affiliation-url: https://statistics.sciences.ncsu.edu/ \ncategories: [Bayesian, MCMC, Spatial, CAR] # self-defined categories\ndraft: false \nformat:\n  html: \n    code-fold: true\nexecute: \n  cache: true\n  freeze: auto\n---\n\n::: {.cell hash='index_cache/html/load-packages_b02ac35d850dd033b8940ef536754e54'}\n\n```{.r .cell-code  code-summary=\"Code: Load the packages\"}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(viridis)\n```\n:::\n\n\n## Intro\n\nHere we will extend the univariate CAR model to the multivariate case. \n\nConsider a spatial domain $\\mathcal{D} \\in \\mathbb{R}^2$ that is partitioned into $n$ areal units. The structure of the spatial domain is captured in the neighborhood matrix. Recall our definition of a neighborhood matrix $\\mathbf{W} = \\{w_{ij}\\}$, where\n$$\nw_{ij} = \n\\begin{cases}\n1 \\quad \\text{if} \\quad j \\in \\mathcal{N}(i),\\\\\n0 \\quad \\text{otherwise}.\n\\end{cases}\n$$\nand by convention $w_{ii}=0$. Further, define $w_{i+} = \\sum_{j=1}^pw_{ij}$, i.e. the number of neighbors of location $i$, $|\\mathcal{N}(i)|$.\n\nIn the univariate case we specified a spatial random effect $\\boldsymbol\\phi = (\\phi_1,\\dots,\\phi_n)$ meant to characterize spatial dependence. In the multivariate case, say of dimension $p$, we specify a $p \\times 1$ spatial random vector $\\boldsymbol\\phi_i = (\\phi_{i1}, \\phi_{i2},\\dots, \\phi_{ip})$ at each location $i$, $i = 1,\\dots,n$. Arrange these vectors as rows in a matrix $\\boldsymbol\\Phi$\n$$\n\\boldsymbol\\Phi = \n\\begin{pmatrix}\n\\boldsymbol\\phi_{1}\\\\\n\\boldsymbol\\phi_2\\\\\n\\vdots\\\\\n\\boldsymbol\\phi_n\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\phi_{11} & \\phi_{12} & \\dots & \\phi_{1p}\\\\\n\\phi_{21} & \\phi_{22} & \\dots & \\phi_{2p}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n\\phi_{n1} & \\phi_{n2} & \\dots & \\phi_{np}\\\\\n\\end{pmatrix}.\n$$\n\nDefine $\\boldsymbol\\phi' = \\text{vec}(\\boldsymbol\\Phi^T)$, i.e. stacked columns of $\\boldsymbol\\Phi^T$. Here we will use $\\boldsymbol\\phi' = \\text{vec}(\\boldsymbol\\Phi^T)$ to characterize spatial dependence.\n\nWe concern ourselves with the joint distribution $\\boldsymbol\\phi'$ by specifying conditional distributions of $\\boldsymbol\\phi_i$.\nUnder the Markov Random Field (MRF) assumption, the conditional distributions of $\\boldsymbol\\phi_i$ can be specified as\n$$\np(\\boldsymbol\\phi_i|\\boldsymbol\\phi_{j\\ne i}, \\boldsymbol\\Gamma_i) = N\\left(\\sum_{i \\sim j} \\mathbf{B}_{ij}\\boldsymbol\\phi_j, \\boldsymbol\\Gamma_i\\right), \\quad i,j = 1,\\dots,n.\n$$\n\nwhere $\\boldsymbol\\Gamma_i$ and $\\mathbf{B}_{ij}$ are $p \\times p$ matrices. Here we use $i \\sim j$ to say that $j$ is in the neighborhood of $i$, i.e. $j \\in \\mathcal{N}(i)$.\n\nThe role of $\\boldsymbol\\Gamma_i$ and $\\mathbf{B}_{ij}$ are analogous to the roles of $\\tau_i^2$ and $b_{ij}$, respectively, in the univariate CAR models. The matrix $\\boldsymbol\\Gamma_i$ is the within-location covariance matrix which describes the dependence of the variables in the vector $\\boldsymbol\\phi_i$. The matrix $\\mathbf{B}_{ij}$ is a matrix that allows us to weight observations from locations in the neighborhood of location $i$. A convenient special case is to set $\\mathbf{B}_{ij} = b_{ij}\\mathbf{I}_p$ where $b_{ij} = w_{ij}/w_{i+}$, i.e. the neighboring observations are equally weighted.\n\nSpecifying the conditional distributions in this way implies the unique joint distribution, via Brook's Lemma, to be\n$$\np(\\boldsymbol\\phi' \\;| \\;\\{\\boldsymbol\\Gamma_i\\}) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\boldsymbol\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}})\\phi\\right\\}\n$$\nwhere $\\boldsymbol\\Gamma$ is block-diagonal with block $\\boldsymbol\\Gamma_i$, and $\\tilde{\\mathbf{B}}$ is $np \\times np$ with the $(i,j)$-th block $\\mathbf{B}_{ij}$.\n\nOf course, the conditions for a proper multivariate normal distribution are symmetry and positive definiteness of $\\boldsymbol\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}})$. \n\nSetting $\\mathbf{B}_{ij} = b_{ij}\\mathbf{I}_p$ where $b_{ij} = w_{ij}/w_{i+}$ leads to the symmetry condition $b_{ij}\\boldsymbol\\Gamma_j = b_{ji}\\boldsymbol\\Gamma_i$. \n\nFurther, a common simplifying assumption would be to consider equal within-location covariance. That is, set $\\boldsymbol\\Gamma_i = w_{i+}^{-1}\\boldsymbol\\Lambda$ where $\\boldsymbol\\Lambda$ is the $p \\times p$ within-location covariance matrix for $\\boldsymbol\\phi_i$ common across spatial locations $i=1,\\dots,n$.\n\nUnder these assumptions we can write $\\boldsymbol\\Gamma = (\\mathbf{D}^{-1}\\otimes\\boldsymbol\\Lambda)$ where $\\mathbf{D}$ is an $n \\times n$ diagonal matrix with $\\mathbf{D}_{ii} = w_{i+}$. And also $\\tilde{\\mathbf{B}} = \\mathbf{B}\\otimes\\mathbf{I}_p$ where $\\mathbf{B}$ is a $n \\times n$ matrix and elements of $\\mathbf{B}$ are $\\mathbf{B} = \\{b_{ij}\\} = \\{w_{ij}/w_{i+}\\}$, not to be confused with the block matrix specification $\\mathbf{B}_{ij}$ given previously. \n\nWith this in mind, we can write the precision of the above joint distribution in an alternate form,\n\n\\begin{align*}\n\n\\Gamma^{-1}(\\mathbf{I}_{np} - \\tilde{\\mathbf{B}}) &= (\\mathbf{D}^{-1} \\otimes \\boldsymbol\\Lambda)^{-1}(\\mathbf{I}_{np} - \\mathbf{B}\\otimes \\mathbf{I}_p)\\\\\n&= (\\mathbf{D} \\otimes \\boldsymbol\\Lambda^{-1})(\\mathbf{I}_{np} - \\mathbf{B}\\otimes \\mathbf{I}_p) & \\text{Kronecker Prod - Inverse}\\\\\n&= (\\mathbf{D} \\otimes \\boldsymbol\\Lambda^{-1}) - (\\mathbf{D} \\otimes \\boldsymbol\\Lambda^{-1})( \\mathbf{B}\\otimes \\mathbf{I}_p) & \\text{(Matrix Mult - distributive wrt matrix addition)}\\\\\n&= (\\mathbf{D} \\otimes \\boldsymbol\\Lambda^{-1}) - (\\mathbf{D}\\mathbf{B}) \\otimes (\\boldsymbol\\Lambda^{-1}\\mathbf{I}_p) & \\text{(Kronecker Prod - mixed-product property)}\\\\\n&= (\\mathbf{D} - \\mathbf{D}\\mathbf{B})\\otimes\\boldsymbol\\Lambda^{-1} & \\text{(Kronecker Prod - distributive wrt matrix addition)}\\\\\n&= (\\mathbf{D} - \\mathbf{W}) \\otimes \\boldsymbol\\Lambda^{-1}\n\\end{align*}\n\nwhere the last step follows from the fact that $\\mathbf{B} = \\mathbf{D}^{-1}\\mathbf{W}$. \n\nNow there is no need to construct a large block-diagonal $\\boldsymbol\\Gamma$ matrix. Also, the neighborhood matrix $\\mathbf{W}$ and $\\mathbf{D}$, the diagonal matrix of its row sums, are fixed and known quantities easily computed outside of any MCMC sampling loop. The joint distribution is then\n\n$$\np(\\boldsymbol\\phi' \\;| \\boldsymbol\\Lambda) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\left((\\mathbf{D} - \\mathbf{W})\\otimes \\boldsymbol\\Lambda^{-1}\\right)\\phi\\right\\}\n$$\nor \n$$\n\\boldsymbol\\phi'|\\boldsymbol\\Lambda \\sim N\\left(\\boldsymbol 0, (\\mathbf{D} - \\mathbf{W})^{-1} \\otimes \\boldsymbol\\Lambda\\right).\n$$\n\nHowever, we again encounter the issue that $(\\mathbf{D} - \\mathbf{W}) \\otimes \\boldsymbol\\Lambda^{-1}$ is singular, since $(\\mathbf{D} - \\mathbf{W})$ is singular. This motivates the introduction of a scalar \"spatial strength\" parameter, $\\rho$, also analogous to the univariate case. There are in fact more general conditions for recovering positive definiteness, but these are not explored here. More details can be found in. . .\n\nIntroducing $\\rho$ results in a proper joint distribution with form\n\n$$\np(\\boldsymbol\\phi' \\;| \\boldsymbol\\Lambda) \\propto \\exp\\left\\{-\\frac{1}{2}\\boldsymbol\\phi^T\\left((\\mathbf{D} - \\rho\\mathbf{W})\\otimes \\boldsymbol\\Lambda^{-1}\\right)\\boldsymbol\\phi\\right\\}\n$$\nprovided that $|\\rho|<1$.\n\nLet's simulate a simple scenario. Let the spatial domain be paritioned into a $25 \\times 25$ regular lattice with $n = 625$ spatial locations. The regular lattice partition will induce a neighborhood matrix $\\mathbf{W}$ and diagonal matrix $\\mathbf{D}$ for the row sums of $\\mathbf{W}$. \n\nLet $p = 2$ so that we have a $p \\times p$ vector $\\boldsymbol\\phi_i$ at each location $i = 1,\\dots,n$. Next, specify the common within-location covariance matrix \n$$\n\\boldsymbol\\Lambda =\n\\begin{pmatrix}\n1 & 0.9\\\\\n0.9 & 1 \n\\end{pmatrix}\n$$\nThis way $\\text{Var}(\\phi_{i1}) = 1$, $\\text{Var}(\\phi_{i2}) = 1$, and $\\text{Corr}(\\phi_{i1}, \\phi_{i2}) = 0.9$. Lastly, set $\\rho = 0.99$ to induce strong spatial correlation. Here is a naive way to sample from the joint distribution for $\\boldsymbol\\phi'$.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_4ff217efe4a8a4e2628b843803833e83'}\n\n```{.r .cell-code}\nn <- 30^2\nspat_domain <- expand.grid(x = 1:sqrt(n), y = 1:sqrt(n))\nspat_domain$label <- 1:n\n\nspat_domain_g <- make_lattice(c(sqrt(n),sqrt(n)), mutual = TRUE)\nW <- as_adjacency_matrix(spat_domain_g, sparse=0)\nD <- diag(rowSums(W))\n\np <- 2\nLambda <- matrix(c(1, 0.9,\n                   0.9, 1), byrow = T, ncol = p)\nrho <- 0.99\n\ninv_Sigma <- kronecker((D-rho*W), solve(Lambda))\n\n# spat_phi <- matrix(backsolve(chol(inv_Sigma), matrix(rnorm(n*p), nrow = n*p)), byrow = T, ncol = p)\n\nspat_phi <- matrix(Rfast::rmvnorm(1, rep(0,n*p), solve(inv_Sigma)), byrow = T, ncol = 2)\n\nspat_domain$phi1 <- spat_phi[,1]\nspat_domain$phi2 <- spat_phi[,2]\n```\n:::\n\n\nSince we specified this example with both strong spatial and strong within-location correlation, plotting the data for $\\phi_{i1}$ and $\\phi_{i2}$, we should expect to observe the same spatial correlation patterns for the first and second elements of $\\boldsymbol\\phi_i$. \n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_41b78fb6af1311f7ef18f4b98f0aa465'}\n\n```{.r .cell-code}\nggplot(spat_domain) +\n  geom_tile(aes(x, y, fill=phi1)) +\n  scale_y_reverse() +\n  scale_fill_gradientn(colors = viridis(10), limits = c(-3.3,3.3)) +\n  coord_fixed() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(spat_domain) +\n  geom_tile(aes(x, y, fill=phi2)) +\n  scale_y_reverse() +\n  scale_fill_gradientn(colors = viridis(10), limits = c(-3.3,3.3)) +\n  coord_fixed() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\nGood news! It looks like we were successful in simulating from the MCAR model! For the next post, we will examine the case where $\\rho$ is not shared among elements of $\\boldsymbol\\phi_i$\n\nEven so, a model which assumes a shared $\\rho$ parameter across elements of $\\boldsymbol\\phi_i$ may be too restrictive by assuming that the \"strength of spatial dependence\" is the same for each variable in the multivariate response. Further models have been developed that allow for different $\\rho_k$ for variables $k=1,\\dots,p$. \n\nThis approach requires a re-arrangement of $\\boldsymbol\\phi$. Where previously $\\boldsymbol\\phi$ stacked $n$ vectors of length $p$ on top of each other, now consider $\\boldsymbol\\phi'$ to stack $p$ vectors of length $n$. That is we collect the $n$ instances of the $p$-th element of $\\boldsymbol\\phi_i$, $i=1,\\dots,n$. This operation is essentially transforming the vectorization of the $n \\times p$ matrix representation of $\\boldsymbol\\phi$ into the vectorization of its transpose and is accomplished via a *commutation* matrix.\n\nSome things to think about. Viewing $\\boldsymbol\\phi$ as a vectoratization of a matrix $\\Phi$. Then we can commute $\\boldsymbol\\phi = \\text{vec}(\\Phi)$ by applying the commutation matrix $\\mathbf{K}^{(p,n)}$ for the result $\\mathbf{K}^{(p,n)}\\text{vec}(\\Phi) = \\text{vec}(\\Phi^T)$. Given that\n\n$$\n\\text{vec}(\\Phi) = \\boldsymbol\\phi \\sim N\\left(\\boldsymbol 0, (\\mathbf{D}-\\rho\\mathbf{W})^{-1} \\otimes \\Lambda\\right)\n$$\n\nthen the result of left multiplying by the commutation matrix yields the distribution,\n$$\n\\begin{align*}\n\\mathbf{K}^{(p,n)}\\text{vec}(\\Phi) = \\text{vec}(\\Phi^T) &\\sim N\\left(\\boldsymbol 0, \\mathbf{K}^{(p,n)}\\left[(\\mathbf{D}-\\rho\\mathbf{W})^{-1} \\otimes \\Lambda\\right]\\left(\\mathbf{K}^{(p,n)}\\right)^T\\right)\\\\\n&\\sim N\\left(\\boldsymbol 0, \\mathbf{K}^{(p,n)}\\left[(\\mathbf{D}-\\rho\\mathbf{W})^{-1} \\otimes \\Lambda\\right]\\mathbf{K}^{(n,p)}\\right)\\\\\n&\\sim N\\left(\\boldsymbol 0, \\left[\\Lambda \\otimes(\\mathbf{D}-\\rho\\mathbf{W})^{-1}\\right]\\right) \n\\end{align*}\n$$\n\nThe effect is that the Kronecker product is commuted. When the resulting Kronecker product is expanded, the elements of the common non-spatial covariance matrix $\\Lambda$ are multiplied with $(\\mathbf{D}-\\rho\\mathbf{W})$ individually as scalars. It is in this form that we can introduce different $\\rho_k$ for each of the $p$ elements. That is, different strengths of spatial correlation for each variate in the multivariate response vector.\n\nThis allows us to \"break up\" elements of $\\Sigma$ and associate them with difference values of $\\rho_k$.\n\n\n\nLet's turn to a simple example. Consider a spatial domain partitioned into $n=4$ areal units and a multivariate response with $p=2$.\n\n\nFirst, the spatial domain.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_31aa882f488ded0d92187c7f34fe220b'}\n\n```{.r .cell-code}\nn <- 4\nspat_domain <- expand.grid(x = 1:sqrt(n), y = 1:sqrt(n))\nspat_domain$label <- 1:n\n```\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_3118916beebf45c203e604821a5418cd'}\n\n```{.r .cell-code}\nggplot(spat_domain) +\n  geom_tile(aes(x, y), linewidth = 2, color = \"grey50\", fill=\"white\") +\n  geom_text(aes(x, y, label=label), size = 15) +\n  coord_fixed() + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nNext, the adjacency matrix $\\mathbf{W}$.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_72ebf1a8f2e6ad66116775a1cdc3d6ab'}\n\n```{.r .cell-code}\nspat_domain_g <- make_lattice(c(sqrt(n),sqrt(n)), mutual = TRUE)\nW <- as.matrix(as_adjacency_matrix(spat_domain_g, sparse=1))\nW\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    1    0\n[2,]    1    0    0    1\n[3,]    1    0    0    1\n[4,]    0    1    1    0\n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_303768a6884c9710617549b6b14d1997'}\n\n```{.r .cell-code}\nB <- W/rowSums(W)\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.0  0.5  0.5  0.0\n[2,]  0.5  0.0  0.0  0.5\n[3,]  0.5  0.0  0.0  0.5\n[4,]  0.0  0.5  0.5  0.0\n```\n:::\n\n```{.r .cell-code}\nBtilde <- kronecker(B, diag(2))\n```\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_641f3605e9ba47f357de1156b92a4d0d'}\n\n```{.r .cell-code}\nD <- diag(rowSums(W))\n\nsolve(D)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.5  0.0  0.0  0.0\n[2,]  0.0  0.5  0.0  0.0\n[3,]  0.0  0.0  0.5  0.0\n[4,]  0.0  0.0  0.0  0.5\n```\n:::\n\n```{.r .cell-code}\np <- 2\ncapSigma <- matrix(c(1,0.7,\n                     0.7,1), byrow = T, ncol=p)\n\ncapLambda <- kronecker(solve(D), capSigma)\n```\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_bf3acb5e5391840dbc80e289022cf7ae'}\n\n```{.r .cell-code}\nA1 <- solve(capLambda)%*%(diag(p*n) - Btilde)\nA2 <- kronecker((D - W), solve(capSigma))\n\nall(A1 == A2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}